{#

 # GT4Py - GridTools4Py - GridTools for Python
 #
 # Copyright (c) 2014-2019, ETH Zurich
 # All rights reserved.
 #
 # This file is part the GT4Py project and the GridTools framework.
 # GT4Py is free software: you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the
 # Free Software Foundation, either version 3 of the License, or any later
 # version. See the LICENSE.txt file at the top-level directory of this
 # distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
 #
 # SPDX-License-Identifier: GPL-3.0-or-later

 ---- Template variables ----

    - arg_fields: [{ "name": str, "dtype": str, "size": int, "origin": [int, int, int], "shape": [int, int, int], "stride": [int, int, int] }]
    - domain: [int, int, int]
    - parameters: [{ "name": str, "dtype": str, "value": str }]
    - out_fields: [{ "name": str, "dtype": str, "size": int }]
    - stencil_short_name: str
    - stencil_unique_name: str
    - test_path: str
#}
#include "computation.hpp"

#include <gtest/gtest.h>

#include <cmath>
#include <fstream>
#include <memory>
#include <string>
#include <vector>
#include <chrono>

namespace {{ stencil_unique_name }}_pyext {

typedef float float32;
typedef double float64;

const float32 float32_precision = 1e-6;
const float64 float64_precision = 1e-10;

const std::string test_path = "{{ test_path }}/";

template <typename T>
bool compare_values(T expected, T actual, T precision) {
  if(std::fabs(expected) < 1e-3 && std::fabs(actual) < 1e-3) {
    if(std::fabs(expected - actual) < precision)
      return true;
  } else {
    if(std::fabs((expected - actual) / (precision * expected)) < 1.0)
      return true;
  }
  return false;
}

template <typename T>
std::unique_ptr<std::vector<T>> read_csv(const std::string& csv_file) {
  auto data = std::unique_ptr<std::vector<T>>(new std::vector<T>{});
  std::fstream fin(csv_file, std::ios::in);
  if(fin.is_open()) {
    std::string line;
    while (std::getline(fin, line, ',')) {
      data->push_back(std::stod(line));
    }
  }
  return data;
}

template <typename T, unsigned N>
void write_csv(const std::string& csv_file, const std::unique_ptr<std::array<T, N>>& data) {
  std::ofstream fout(csv_file);
  if(fout.is_open()) {
    fout.precision(18);
    for(int i = 0; i < N; ++i) {
      fout << std::scientific << data->at(i);
      if(i < N - 1)
        fout << ",";
    }
    fout << "\n";
  }
}

TEST(TestGT4Py, {{ stencil_short_name }}) {
  std::array<unsigned, 3> domain{ {{ domain[0] }}, {{ domain[1] }}, {{ domain[2] }} };
{% for field in arg_fields -%}
  std::array<unsigned, 3> {{ field.name }}_origin{ {{ field.origin[0] }}, {{ field.origin[1] }}, {{ field.origin[2] }} };
{% endfor -%}


{% for param in parameters -%}
  {{ param.dtype }} {{ param.name }} = {{ param.value }};
{% endfor -%}


{% for field in arg_fields -%}
  std::unique_ptr<std::array<{{ field.dtype }}, {{ field.size }}>> {{ field.name }}(new std::array<{{ field.dtype }}, {{ field.size }}>{
  #include "data/{{ field.name }}.csv"
  });
{% endfor -%}


{% for field in arg_fields -%}
  auto bi_{{ field.name }} = BufferInfo{3, { {{ field.shape[0] }}, {{ field.shape[1] }}, {{ field.shape[2] }} }, { {{ field.stride[0] }}, {{ field.stride[1] }}, {{ field.stride[2] }} }, {{ field.name }}->data()};
{% endfor -%}


  double start_run_time =
      static_cast<double>(
          std::chrono::duration_cast<std::chrono::nanoseconds>(
              std::chrono::high_resolution_clock::now().time_since_epoch())
              .count()) * 1e-9;

  run(domain,
{%- set comma = joiner(", ") -%}
{%- for field in arg_fields -%}
      {{- comma() }}
      bi_{{ field.name }}, {{ field.name }}_origin
{%- endfor -%}
{%- for param in parameters -%}
      {{- comma() }}
      {{ param.name }}
{%- endfor %});

  double end_run_time = static_cast<double>(
      std::chrono::duration_cast<std::chrono::nanoseconds>(
          std::chrono::high_resolution_clock::now().time_since_epoch())
          .count() * 1e-9);

{% for field in out_fields -%}
  auto {{ field.name }}_out = read_csv<{{ field.dtype }}>(test_path + "data/{{ field.name }}_out.csv");
  if(!{{ field.name }}_out->empty()) {
    ASSERT_EQ({{ field.name }}->size(), {{ field.name }}_out->size());
    for (int i = 0; i < {{ field.name }}->size(); ++i) {
      bool matched = compare_values<{{ field.dtype }}>({{ field.name }}_out->at(i), {{ field.name }}->at(i),
                                    {{ field.dtype }}_precision);
      if(!matched)
        write_csv<{{ field.dtype }}, {{ field.size }}>(test_path + "data/{{ field.name }}_fail.csv", {{ field.name }});
      ASSERT_TRUE(matched)  << {{ field.name }}_out->at(i) << " !~ " <<
                               {{ field.name }}->at(i) << " at " << i;
    }
  }
{% endfor -%}

  std::cout << "{{ stencil_short_name }} run_time: "
            << end_run_time - start_run_time << std::endl;

  SUCCEED();
} // TestGT4Py_{{ stencil_short_name }}

} // namespace {{ stencil_unique_name }}_pyext
