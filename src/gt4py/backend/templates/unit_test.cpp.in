{#

 # GT4Py - GridTools4Py - GridTools for Python
 #
 # Copyright (c) 2014-2019, ETH Zurich
 # All rights reserved.
 #
 # This file is part the GT4Py project and the GridTools framework.
 # GT4Py is free software: you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the
 # Free Software Foundation, either version 3 of the License, or any later
 # version. See the LICENSE.txt file at the top-level directory of this
 # distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
 #
 # SPDX-License-Identifier: GPL-3.0-or-later

 ---- Template variables ----

    - arg_fields: [{ "name": str, "dtype": str, "size": int, "data": str, "origin": [int, int, int], "shape": [int, int, int], "stride": [int, int, int] }]
    - domain: [int, int, int]
    - parameters: [{ "name": str, "dtype": str, "value": str }]
    - gt_backend: str
    - module_name: str
    - stencil_short_name: str
    - stencil_unique_name: str
#}

#include "computation.hpp"

#include <gtest/gtest.h>

#include <vector>
#include <chrono>

namespace {{ stencil_unique_name }} {

TEST(TestGT4Py, {{ stencil_short_name }}) {
  std::array<unsigned, 3> domain{ {{ domain[0] }}, {{ domain[1] }}, {{ domain[2] }} };
{% for field in arg_fields %}
  std::array<unsigned, 3> {{ field.name }}_origin{ {{ field.origin[0] }}, {{ field.origin[1] }}, {{ field.origin[2] }} };
{% endfor %}
{% for param in parameters %}
  {{ param.dtype }} {{ param.name }} = {{ param.value }};
{% endfor %}

{% for field in arg_fields %}
  std::array<{{ field.dtype }}, {{ field.size }}> {{ field.name }} { {{ field.data }} };
{% endfor %}

{% for field in arg_fields %}
  auto bi_{{ field.name }} = BufferInfo{3, { {{ field.shape[0] }}, {{ field.shape[1] }}, {{ field.shape[2] }} }, { {{ field.stride[0] }}, {{ field.stride[1] }}, {{ field.stride[2] }} }, {{ field.name }}.data() };
{% endfor %}

  double start_run_cpp_time =
      static_cast<double>(
          std::chrono::duration_cast<std::chrono::nanoseconds>(
              std::chrono::high_resolution_clock::now().time_since_epoch())
              .count()) * 1e-9;

  //run(domain, bi_uc_in, uc_in_origin, bi_delpc, delpc_origin, bi_pkc,
  //    pkc_origin, bi_gz, gz_origin, bi_rdxc, rdxc_origin, hydrostatic, dt2);
  run(domain,
{%- set comma = joiner(", ") -%}
{%- for field in arg_fields -%}
        {{- comma() }}
        bi_{{ field.name }}, {{ field.name }}_origin
{%- endfor -%}
{%- for param in parameters -%}
        {{- comma() }}
        {{ param.name }}
{%- endfor %});

  double end_run_cpp_time = static_cast<double>(
      std::chrono::duration_cast<std::chrono::nanoseconds>(
          std::chrono::high_resolution_clock::now().time_since_epoch())
          .count() * 1e-9);
  std::cerr << "{{ stencil_short_name }} run_time: "
            << end_run_cpp_time - start_run_cpp_time << std::endl;

  SUCCEED();
} // namespace {{ stencil_unique_name }}
