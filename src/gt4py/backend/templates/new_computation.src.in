{#

 # GT4Py - GridTools4Py - GridTools for Python
 #
 # Copyright (c) 2014-2019, ETH Zurich
 # All rights reserved.
 #
 # This file is part the GT4Py project and the GridTools framework.
 # GT4Py is free software: you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the
 # Free Software Foundation, either version 3 of the License, or any later
 # version. See the LICENSE.txt file at the top-level directory of this
 # distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
 #
 # SPDX-License-Identifier: GPL-3.0-or-later

 ---- Template variables ----

    - arg_fields: [{ "name": str, "dtype": str, "layout_id": int }]
    - constants: { name:str : str }
    - backend: str
    - halo_sizes: [int]
    - k_axis: { "n_intervals": int, "offset_limit": int}
    - max_ndim: int
    - multi_stages: [{ "name": str, "exec": str, "interval": [{ "level": str, "offset": int }], "steps": [{
            "args": [
                {
                    "name": str
                    "access_type": str
                    "extent": [int] | None
                }
            ],
            "regions": [
                {
                    "interval_start": (level:int, offset:int),
                    "interval_end": (level:int, offset:int),
                    "body": str
                }
            ],
            "extents": [int]
        }]}]
    - parameters: [{ "name": str, "dtype": str }]
    - stencil_unique_name: str
    - tmp_fields: [{ "name": str, "dtype": str }]
    - access_vars: [{ "name": str, "expr": str, "itype": str }]
    - block_sizes: [int]
    - max_extents: [int]
    - max_threads: int
    - extra_threads: int
    - do_k_parallel: bool
#}

#include "computation.hpp"

#include <array>
#include <cassert>
#include <stdexcept>

namespace {{ stencil_unique_name }} {

namespace {

// Axis
static constexpr uint_t level_offset_limit = {{ k_axis.offset_limit }};
static constexpr uint_t k_axis_n_intervals = {{ k_axis.n_intervals }};

static constexpr uint_t ndim = {{ max_ndim }};

// These halo sizes are used to determine the sizes of the temporaries
static const uint_t halo_sizes[] = { {{ halo_sizes[0] }}, {{ halo_sizes[1] }}, {{ halo_sizes[2] }} };
{% if tmp_fields -%}
static int temp_offset = -1;
{%- endif %}

{% if constants -%}
// Constants
{%- endif %}
{% for name, value in constants.items() %}
static constexpr auto {{ name }} = {{ value }};
{%- endfor %}

template <typename DataType = float64_t> struct data_store_t {
    std::array<uint_t, ndim> shape;
    std::array<uint_t, ndim> strides;
    DataType* ptr;

    const DataType* data() const noexcept { return ptr; }

    DataType* data() noexcept { return ptr; }

    inline int index(int i, int j, int k) const {
      return int(i * strides[0]) + int(j * strides[1]) + int(k * strides[2]);
    }

    // read-operator
    const DataType& operator()(int i, int j = 0, int k = 0) const {
      return ptr[index(i, j, k)];
    }

    // write-operator
    DataType& operator()(int i, int j = 0, int k = 0) {
      return ptr[index(i, j, k)];
    }
};

template<typename DataType>
data_store_t<DataType> make_data_store(const BufferInfo& bi,
                                       const std::array<uint_t, ndim>& compute_domain,
                                       const std::array<uint_t, ndim>& origin) {
    // ptr, dims and strides are "outer domain" (i.e., compute domain + halo
    // region). The halo region is only defined through `make_grid` (and
    // currently, in the storage info)
    std::array<uint_t, ndim> dims{};
    std::array<uint_t, ndim> strides{};
    DataType* ptr = static_cast<DataType*>(bi.ptr);
    for (uint_t i = 0; i < ndim; ++i) {
        strides[i] = bi.strides[i] / sizeof(DataType);
        ptr += strides[i] * (origin[i] - halo_sizes[i]);
        dims[i] = compute_domain[i]+2*origin[i];
    }
    return data_store_t<DataType>{dims, strides, ptr};
}

{% if tmp_fields -%}
template<typename DataType>
data_store_t<DataType> make_temp_store(const std::array<uint_t, ndim>& compute_domain) {
    // Compute dims
    uint_t data_size = 1;
    std::array<uint_t, ndim> dims{};
    for(uint_t i = 0; i < ndim; ++i) {
      dims[i] = halo_sizes[i] + compute_domain[i] + halo_sizes[i];
      data_size *= dims[i];
    }

    // Compute strides and offset
    uint_t offset = 0;
    uint_t stride = 1;
    std::array<uint_t, ndim> strides{};
    for(int i = ndim - 1; i >= 0; --i) {
      strides[i] = stride;
      offset += stride * halo_sizes[i];
      stride *= dims[i];
    }

    // Allocate pointer and shift by halo offset...
{%- if "cuda" in backend %}
    DataType* ptr;
    cudaMalloc((void**) &ptr, data_size * sizeof(DataType));
{%- else %}
    DataType* ptr = new DataType[data_size];
{%- endif %}
    ptr += offset;
    temp_offset = offset;

    return data_store_t<DataType>{dims, strides, ptr};
}

template<typename DataType>
void free_temp_store(data_store_t<DataType>& temp) {
    temp.ptr -= temp_offset;
{%- if "cuda" in backend %}
    cudaFree(temp.ptr);
{%- else %}
    delete[] temp.ptr;
{%- endif %}
}
{%- endif %}
}  // namespace

{% if "cuda" in backend -%}
{# NOTE i_stride == 1, e.g. strides = (1, 64, 3520)
{% set jboundary_limit = block_sizes[1] + max_extents[3] - max_extents[2] %}
{% set iminus_limit = jboundary_limit + (1 if max_extents[0] < 0 else 0) %}
{% set iplus_limit = iminus_limit + (1 if max_extents[1] > 0 else 0) %} #}
{# TODO Actually compute these...
{% set k_interval_min = 0 %}
{% set k_interval_diff = 0 %}
{% set k_interval_offset = -1 %} #}
{% for multi in multi_stages %}
__global__ void __launch_bounds__({{ max_threads }}) {{ multi.name }}_kernel(
    const int i_min, const int i_max, const int i_size,
    const int j_min, const int j_max, const int j_size,
    const int k_min, const int k_max, const int k_size,
    const uint_t* data_strides,
{% if tmp_fields -%}
    const uint_t* temp_strides,
{%- endif %}
{%- set comma = joiner(", ") %}
{%- for field in arg_fields -%}
    {{- comma() }}
    {{ field.dtype }}* const {{ field.name }}
{%- endfor -%}
{%- for field in tmp_fields -%}
    {{- comma() }}
    {{ field.dtype }}* const {{ field.name }}
{%- endfor -%}
{%- for param in parameters -%}
    {{- comma() }}
    const {{ param.dtype }} {{ param.name }}
{%- endfor -%}
) {

    int i =  i_min + (blockDim.x * blockIdx.x + threadIdx.x);
    int j =  j_min + (blockDim.y * blockIdx.y + threadIdx.y);
    //int k =  k_min + (blockDim.z * blockIdx.z + threadIdx.z);

    for (int k = k_min + 0; k <= k_max + 0; ++k) {
    {%- for step in multi.steps %}
      {%- for region in step.regions %}
          if(i >= {{ step.extents[0] }} && i <= i_max + {{ step.extents[1] }} &&
             j >= {{ step.extents[2] }} && j <= j_max + {{ step.extents[3] }}) {
          {%- for access in access_vars %}
            {{ access.itype }} {{ access.name }} = {{ access.expr }};
          {%- endfor %}
          {{ region.body }}
      }
    {%- endfor %}
    {%- if not loop.last %}
    __syncthreads();
    {%- endif -%}
{%- endfor %}
{#   data_idx += k_stride;
{%- if tmp_fields %}
    tmp_idx += k_stride_tmp;
{% endif %}  #}
  }
}
{% endfor %}
{% endif -%}

// Run actual computation
void run(const std::array<uint_t, ndim>& domain,
{%- set comma = joiner(", ") %}
{%- for field in arg_fields -%}
         {{- comma() }}
         const BufferInfo& bi_{{ field.name }} {{- comma() -}} const std::array<uint_t, ndim>& {{ field.name }}_origin
{%- endfor %}
{%- for param in parameters %}
         {{- comma() }}
         {{ param.dtype }} {{ param.name }}
{%- endfor %}) {
    // Initialize data stores from input buffers
{%- for field in arg_fields %}
    auto {{ field.name }}_ds = make_data_store<{{ field.dtype }}>(bi_{{ field.name }}, domain, {{ field.name }}_origin);
{%- endfor %}

{% if tmp_fields -%}
    // Allocate temporary storages
{%- for field in tmp_fields %}
    auto {{ field.name }}_ds = make_temp_store<{{ field.dtype }}>(domain);
{%- endfor %}
{%- endif %}
    const int i_min = halo_sizes[0];
    const int i_max = domain[0] + i_min - 1;
    const int j_min = halo_sizes[1];
    const int j_max = domain[1] + j_min - 1;
    const int k_min = halo_sizes[2];
    const int k_max = domain[2] + k_min - 1;

    const auto data_strides = {{ arg_fields[0].name }}_ds.strides;
{%- if tmp_fields %}
    const auto temp_strides = {{ tmp_fields[0].name }}_ds.strides;
{%- endif %}

{# --- CUDA --- #}
{%- if "cuda" in backend %}
    {% for multi in multi_stages %}
    const unsigned int i_size = domain[0] - 2 * i_min;
    const unsigned int j_size = domain[1] - 2 * j_min;
    const unsigned int k_size = domain[2] - 2 * k_min;
    const unsigned int i_block_size = (i_size + {{ block_sizes[0] }} - 1) / {{ block_sizes[0] }};
    const unsigned int j_block_size = (j_size + {{ block_sizes[1] }}  - 1) / {{ block_sizes[1] }};
{%- if do_k_parallel %}
    const unsigned int k_block_size = (domain[2] + {{ block_sizes[2] }} - 1) / {{ block_sizes[2] }};
{%- else %}
    const unsigned int k_block_size = 1;
{%- endif %}

    dim3 gdim(i_block_size, j_block_size, k_block_size);
    dim3 bdim({{ block_sizes[0] }}, {{ block_sizes[1] }} + {{ extra_threads }}, 1);

    {{ multi.name }}_kernel<<<gdim, bdim>>>(
    i_min, i_max, i_size,
    j_min, j_max, j_size,
    k_min, k_max, k_size,
    data_strides.data(),
    {%- set comma = joiner(", ") %}
    {%- set extra_indent=4 %}
{%- for field in arg_fields -%}
    {{- comma() }}
    {{ field.name }}.ptr
{%- endfor %}
{%- if tmp_fields %}
    temp_strides.data(),
{%- for field in tmp_fields %}
    {{- comma() }}
    {{ field.name }}.ptr
{%- endfor %}
{%- endif %}
{%- for param in parameters %}
    {{- comma() }}
    {{ param.name }}
{%- endfor %});
{%- set extra_indent=0 %}
    {% endfor %}
{# --- C++ --- #}
{%- else %}

{%- for field in arg_fields %}
    {{ field.dtype }}* {{ field.name }} = {{ field.name }}_ds.ptr;
{%- endfor %}
{% if tmp_fields -%}
{%- for field in tmp_fields %}
    {{ field.dtype }}* {{ field.name }} = {{ field.name }}_ds.ptr;
{%- endfor %}
{%- endif -%}

{% for multi in multi_stages %}
{%- if multi.exec == "parallel" %}
    #pragma omp parallel for schedule(runtime)
{%- endif %}
{%- if multi.exec == "backward" %}
    for (int k = k_{{ multi.interval[1].level }} + {{ multi.interval[1].offset }} + {{ multi.steps[0].extents[5] }}; k >= k_{{ multi.interval[0].level }} + {{ multi.interval[0].offset }} + {{ multi.steps[0].extents[4] }}; --k) {
{%- else %}
    for (int k = k_{{ multi.interval[0].level }} + {{ multi.interval[0].offset }} + {{ multi.steps[0].extents[4] }}; k <= k_{{ multi.interval[1].level }} + {{ multi.interval[1].offset }} + {{ multi.steps[0].extents[5] }}; ++k) {
{%- endif %}
{%- for step in multi.steps %}
    {%- for region in step.regions %}
      for (int i = i_min + {{ step.extents[0] }}; i <= i_max + {{ step.extents[1] }}; ++i) {
        #pragma omp simd
        for (int j = j_min + {{ step.extents[2] }}; j <= j_max + {{ step.extents[3] }}; ++j) {
{%- for access in access_vars %}
          {{ access.itype }} {{ access.name }} = {{ access.expr }};
{%- endfor %}
          {{ region.body }}
        }
      }
    {%- endfor %}
{%- endfor %}
    }
{% endfor %}
{%- endif %}

{%- if tmp_fields -%}
    // Free temporary storages
{%- for field in tmp_fields %}
    free_temp_store<{{ field.dtype }}>({{ field.name }}_ds);
{%- endfor %}
{%- endif %}

}  // run
}  // namespace {{ stencil_unique_name }}
