{#

 # GT4Py - GridTools4Py - GridTools for Python
 #
 # Copyright (c) 2014-2020, ETH Zurich
 # All rights reserved.
 #
 # This file is part the GT4Py project and the GridTools framework.
 # GT4Py is free software: you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the
 # Free Software Foundation, either version 3 of the License, or any later
 # version. See the LICENSE.txt file at the top-level directory of this
 # distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
 #
 # SPDX-License-Identifier: GPL-3.0-or-later

 ---- Template variables ----

    - arg_fields: [{ "name": str}]
    - dawn_namespace: str
    - gt_backend: str
    - header_file: str
    - parameters: [{ "name": str, "dtype": str }]
    - stencil_short_name: str
    - stencil_unique_name: str
    - halos: [int, int, int]
#}

#include "{{ header_file }}"



#include <array>
#include <cassert>
#include <stdexcept>

typedef mlir::Type ElementType;

// mlir array type
template <typename Elem, size_t Rank> struct MemRef {
  Elem *allocatedPtr;
  Elem *alignedPtr;
  int64_t offset;
  std::array<int64_t, Rank> sizes;   // omitted when rank == 0
  std::array<int64_t, Rank> strides; // omitted when rank == 0

  template <typename... Index>
  Elem &operator()(const Index ...indices);

  template <typename... Index>
  const Elem &operator()(const Index ...indices) const;
};

//namespace {{ stencil_unique_name }} {
namespace {

// mlir array type
template <typename Elem, size_t Rank> struct MemRef {
  Elem *allocatedPtr;
  Elem *alignedPtr;
  int64_t offset;
  std::array<int64_t, Rank> sizes;   // omitted when rank == 0
  std::array<int64_t, Rank> strides; // omitted when rank == 0

  template <typename... Index>
  Elem &operator()(const Index ...indices);

  template <typename... Index>
  const Elem &operator()(const Index ...indices) const;
};

typedef MemRef<ElementType, 1> MemRefType1D;
typedef MemRef<ElementType, 2> MemRefType2D;
typedef MemRef<ElementType, 3> MemRefType3D;

// access overloads for 1D array
template <>
template <>
const ElementType &MemRef<ElementType, 1>::operator()<int64_t>(const int64_t i) const {
  return alignedPtr[offset + strides[0] * i];
}

template <>
template <>
ElementType &MemRef<ElementType, 1>::operator()<int64_t>(const int64_t i) {
  return alignedPtr[offset + strides[0] * i];
}

// access overloads for 2D array
template <>
template <>
const ElementType &MemRef<ElementType, 2>::operator()<int64_t, int64_t>(const int64_t i, const int64_t j) const {
  return alignedPtr[offset + strides[1] * i + strides[0]];
}

template <>
template <>
ElementType &MemRef<ElementType, 2>::operator()<int64_t, int64_t>(const int64_t i, const int64_t j) {
  return alignedPtr[offset + strides[1] * i + strides[0]];
}

// access overloads for 3D array
template <>
template <>
const ElementType &MemRef<ElementType, 3>::operator()<int64_t, int64_t, int64_t>(const int64_t i, const int64_t j,
                                           const int64_t k) const {
  return alignedPtr[offset + strides[2] * i + strides[1] * j + strides[0] * k];
}
template <>
template <>
ElementType &MemRef<ElementType, 3>::operator()<int64_t, int64_t, int64_t>(const int64_t i, const int64_t j,
                                     const int64_t k) {
  return alignedPtr[offset + strides[2] * i + strides[1] * j + strides[0] * k];
}

// allocate MemRefs
MemRefType1D allocateMemRef(const int64_t size) {
  MemRefType1D result;
  // initialize the size
  result.sizes[0] = size;
  // initialize the strides
  result.strides[0] = 1;
  result.offset = HALO_WIDTH * result.strides[0];
  result.allocatedPtr = new ElementType[size + (32 - HALO_WIDTH)];
  result.alignedPtr = &result.allocatedPtr[(32 - HALO_WIDTH)];
  return result;
}

MemRefType2D allocateMemRef(const std::array<int64_t, 2> sizes) {
  MemRefType2D result;
  // initialize the size
  result.sizes[1] = sizes[0];
  result.sizes[0] = sizes[1];
  // initialize the strides
  result.strides[1] = 1;
  result.strides[0] = result.sizes[1];
  result.offset = HALO_WIDTH * result.strides[0] +
                  HALO_WIDTH * result.strides[1];
  const int64_t allocSize = sizes[0] * sizes[1];
  result.allocatedPtr = new ElementType[allocSize + (32 - HALO_WIDTH)];
  result.alignedPtr = &result.allocatedPtr[(32 - HALO_WIDTH)];
  return result;
}

MemRefType3D allocateMemRef(const std::array<int64_t, 3> sizes) {
  MemRefType3D result;
  // initialize the size
  result.sizes[2] = sizes[0];
  result.sizes[1] = sizes[1];
  result.sizes[0] = sizes[2];
  // initialize the strides
  result.strides[2] = 1;
  result.strides[1] = result.sizes[2];
  result.strides[0] = result.sizes[2] * result.sizes[1];
  result.offset = HALO_WIDTH * result.strides[0] +
                  HALO_WIDTH * result.strides[1] +
                  HALO_WIDTH * result.strides[2];
  const int64_t allocSize = sizes[0] * sizes[1] * sizes[2];
  result.allocatedPtr = new ElementType[allocSize + (32 - HALO_WIDTH)];
  result.alignedPtr = &result.allocatedPtr[(32 - HALO_WIDTH)];
  return result;
}

template <typename MemRefType>
void freeMemRef(MemRefType &ref) {
  delete ref.allocatedPtr;
  ref.allocatedPtr = nullptr;
  ref.alignedPtr = nullptr;
}

// Run actual computation
void run(const std::array<gt::uint_t, 3>& domain,
{%- set comma = joiner(", ") %}
{%- for field in arg_fields -%}
         {{- comma() }}
         const BufferInfo& bi_{{ field.name }} {{- comma() -}} const std::array<gt::uint_t, 3>& {{ field.name }}_origin
{%- endfor %}
{%- for param in parameters %}
         {{- comma() }}
         {{ param.dtype }} {{ param.name }}
{%- endfor %})
{
    // Initialize data stores from input buffers
{%- for field in arg_fields %}
    auto ds_{{ field.name }} = make_data_store<double>(bi_{{ field.name }}, domain, {{ field.name }}_origin);
{%- endfor %}

    // create computation
    dawn_generated::{{ dawn_namespace }}::{{ stencil_short_name }} computation{make_domain(domain)};

    // Update global parameters
{%- for param in parameters %}
    computation.set_{{ param.name }}({{ param.name }});
{%- endfor %}

    // Run computation and wait for the synchronization of the output stores
    computation.run(
        {%- set comma = joiner(", ") %}
{%- for field in arg_fields -%}
        {{ comma() }}ds_{{ field.name }}
{%- endfor %});
        // computation_.sync_bound_data_stores();
}

}  // namespace {{ stencil_unique_name }}
